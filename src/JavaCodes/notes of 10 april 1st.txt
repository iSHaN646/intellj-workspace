q1->what do you mean by unicode in java?

ans1->
an international encoding standard for use with different languages and scripts, 
by which each letter, digit, or symbol is assigned a unique numeric value that applies
 across different platforms and programs.

q2->why char primitive data types take 2 bytes in java?

ans2->
in java , char follows unicode encoding scheme which supports 60+ languages due to 
which it ranges from 0 to 65535 which cannot be stored on 1 byte whereas in c/c++
ascii scheme is followed supporting only english language ranges from 0 to 255 which 
can be stored in 1 byte.

q3->what are the data types in java?
ans3-> we have two categories in java->

1. Primitive datatype-> As primitive datatype we have already read in c language
(int,float,char,byte) but string datatype is not available in c, to hold any string 
in c language we have to create char array which is difficult approach while 
using string in c language because array data structure we have to define while
holding any string but in java String class introduced in java.

2. Non-Primitive datatype-> String is a non-primitive datatype introduced in java
which hold directly string. String class hold directly string we dont need to 
create char array. Whenever i am creating the string class object, the obj of 
string stored inside the string constant pool.

q4-> How to create a string object?
ans4-> String a = "Real";   ->  string constant pool
String a =  new String("abc");   -> heap

First approach: is the best methology to create string object

Note: 1. We have wrapper classes in java which is used for conversion, specific datatype 
value to another datatype.

2. but if we try to convert string "abc" to integer type we get NumberFormatException
whereas converting string "101" to integer is perfectly fine.

3. if we do not write main method in our program , it will compile fine bcoz there 
is no syntax error and no memory allocation takes place at compile time
but when we run our program jvm will get activated which will first search for
main method in our program,it will throw error ->

Error: Main method not found in class Test, please define the main method as:
   public static void main(String[] args)
or a JavaFX application class must extend javafx.application.Application

Note: THIS keyword

this keyword represent current object of class.
CASE1: suppose i have two objects of same class, i have to check
which current thread is activated in my program we can analyze 
with this keyword.

q5-> what is diff bw equality operator(==) and equals method?

ans5-> Equality operator:
1. if we are using equality operator with the integer variables,
it will check values of variables.
2. if we are using equality operator to check the objects in that 
case it will check address of objects.

eg->
Test t=new Test();
Test t1=new Test();

if(t==t1){
	System.out.println("hi");
}else{
	System.out.println("bie");  //ans
}

Equals Method:
equals method always check the content of two strings

Both equals method and equality operator are used to compare two
objects in java. equality operator is an operator and equals is a
method defined in String class but equality operator compares 
reference of memory location of objects inside heap area,whether 
they point to same location or not.
In general both equals and equality operator in java are used to 
compare objects to check equality but there are some of differences
bw the two->
1. The main diff bw the equals method and equality operator is 
that one is method and second one is operator.
2. We can use equality operator for references comparision
(addresses comparision) and .equals method for content comparision
In simple words, equality operator check if both objects point to
same memory allocation whereas equals method check comparision of
values inside the object.

Q5-> Diff bw reference variable and variable?
ans5->
int b=10; where b is a variable which holds value
Test t= new Test(); where t is a reference variable which holds objects

Variable can hold only values, we can define variable in c language 
where object concept is not available.
But reference variable are those variable which hold the object

Note: 1. exit(Integer) used to shutdown the jvm, so all the code after
the exit statement will not execute. 

2. If there is no constructor in class, but you are calling constructor
using new keyword ,then compiler will automatically insert the
default constructor.

Imp:Note: 1. if we want to restrict any class from being creating objects
using new keyword, make the constructor of that class private.
eg: System class have private constructor, you cannot create its
object.

Private Constructor:

if i am creating any private constructor inside the class or making 
any constructor as private, we cannot create object of that class
outside the class.

Method overloading:

same method name having diff parameters, we can achieve method 
overloading concept

void println(int a){};
void println(Long a){};

In java, two or more methods may have the same name, if they differ
in parameters(diff no. of parameters or diff types of parameters or both)
These method are called overload methods and this feature is called
method overloading.

Q6: Why method overloading?
ans6:

Suppose you have to perform the addition method on given no.,but
there can be any no. of arguments(Lets say either 2 or 3 arguments)
In order to complete the task, you can create two method .
int sum2(int a,int b);
int sum3(int a,int b,int c);

However other programmers as well as you in the future may get confused
as the behaviour of both methods are same but differ by name.
The better way to complish this task is by overloading method and
depending upon the argument passed, one of the overloaded method
is called, this helps to increase the readability of program.

Polymorphism:
Polymorphism divided into 2 phases:
1. Overloading(Compile time Polymorphism)   2. Overriding(runtime polymorphism)

Overloading:
Overloading is known as compile time polymorphism checking methods parameters
at time of compilation makes overloading concept as compile time polymorphism.

eg: Compile time error
void fun(int a){}
void fun(int a){}
psvm{
       fun(10,10.5f);     // checking parameters at compile time
}

System class:

System class having private constructor we cannot create the object of
system class but we have permission to create the reference variable
of system class


Note: Not creating the object of System as private constructor
but creating the reference of System class
 System sc=null;   // Reference variable
 sc.out.println("hello"); // Working

 Note: Static:
 Context of the class : is the memory name where all the static var,methods,
 blocks will be allocated at the compile time.

 Defining
 public static void main(String args[]){}

 q7->Why main method define static in java programming?
 ans7->
 We know non-static methods will be called after object creation, if java
 people defined main method as non-static programmer having the responsibility
 to create the object of that class where main method is defined, but
 static concept is a part of compile time memory allocation and we can
 call static data members and method through className here at the runtime
 classLoader having the responsibility to load the .class, main method will
 be called through class name because main method is static.

Refer to NstaticInSt:
Note: We cannot use non-static reference variable in static methods.


wap to concatenate two strings string values will be given through command line
argument?

wap getting values from the command line argument , you have to check
both the strings are equal or not?

IMP:note:
Refer to PracticeTest and PracticeTestMain:
As PracticeTest have private constructor,we cannot create object in main class
but we are creating static function in PracticeTest class which will return
the object of class(this concept is called factory design method).

Factory method(Factory design pattern) or static methods:
Mainly static methods are factory methods which returns object of class, in
real world terminology IT professionals follow the design pattern in their
projects known as factory design pattern.Factory design pattern is used
to create the factory and serve the objects to other classes, mainly this
design pattern is used for database connectivity realtime projects.

Inheritance:
It is the one of key feature of oop that allows us to create a new class from
existing class.
The new class that is created is known as subclass,child or derived class
and the existing class from where that child class is derived is known as
super class,parent class,base class.
The extends keyword is used to perform inheritance in java.

package JavaCodes;

 class inheritance {

    public inheritance() {
       System.out.println("inheritance class constructor"); //1
   }
   void fun() {
       System.out.println("hello i am in fun()"); //2
   }
}

public class child extends inheritance {

    public static void main(String[] args) {
        child c = new child();
         c.fun();
    }
}

Every non-inheriting class inherits Object class.
Object class have foll functions:
1. void finalize();
2. boolean equals(Object o);
3. int hashCode();
4. void main(String[] args);
5. void notify();
5. void notifyAll();
5. String toString();
5. void wait();
5. void wait(long timeout);
5. void wait(long timeout,int nanos);
6.    getClass();
package JavaCodes;

 class inheritance extends Object{


}

public class child extends inheritance {

    public static void main(String[] args) {
        child c = new child();
         c.hashcode();
    }
}

Is a relationship(Inheritance):
In java,inheritance is an Is a relationship i.e we use inheritance only
if there exist an Is a relationship bw two classes. For eg:
1. Car is a vehicle

class Vehicle{}
class Car extends Vehicle{}

here car can inherit from vehicle and car is a subclass of vehicle.

q-> Why we use inheritance?
ans->
1. The most important use of inheritance in java, is code re-usability.
The code that is present in parent class be directly used by child class.
2. Method overriding is also known as runtime polymorphism, hence we can
achieve polymorphism in java with help of inheritance.

Types of inheritance:
1. Single inheritance->   B extends A
In single inheritance, a single subclass extends from the single superclass.

2. Multi-level inheritance-> C extends B and B extends A
in multi-level inheritance, a subclass extend from a super class and then
same subclass act as a superclass from the another class.

3. Hierarchical inheritance-> Only A is super class and every other class
extends A class
in hierarchical inheritance, multiple subclass extend from a single superclass

4. Multiple inheritance-> A and B class are super classes which is extended
by class C
class C extends A,B
C c=new C();
c.fun();//ambiguity

5. Hybrid inheritance-> Class B and C extends class A, and class D
extends class B and C.
Hybrid inheritance is a combination of two or more type of inheritance.

Super Keyword:
class A{ int a=10; }
class B extends A{
    int a=20;
    void foo(){
        int a=30;
        System.out.println(a); //30
        System.out.println(this.a); //20
        System.out.println(super.a); //10 //super keyword is used in three cases:
//   Case1: Using super in case of variables we get access of super class
//   variables.
//   Case2: Super keyword can be used in case of methods,we can call
//   super class methods with help of super keyword.
//   Case3: We can call super class constructor with help of super keyword
     }
    public static void main(String args[]){
        B b=new B();
        b.foo();
    }
}

final keyword:
final is non-access modifier, applicable only to a variable,method or class.
final keyword is used in diff contexts:
1. final variable    2. final class    3. final methods

final variable:
When the variable is declared as final, its value cannot be changed and
it has been initialized only once. This is useful for declaring constant
or other values that should not be modified.

final method:
When the method is declared as final, it cannot be overriden by subclass,
it is used for methods that are part of a class public api and should
not be modified in subclasses.

final class:
When a class is declared as final, it cannot be extended by a subclass,
this is useful for classes that are intended to be used has is and should
not be modified or extended.

Overriding(runtime polymorphism):

class Test{
    void fun(){
        sout("hi");
    }
}
class Real extends Test{
    void fun(){
        sout("bie");
    }

    psvm(String args[]){
        Real t=new Real();
        t.fun(); //bie
    }
}

Overriding in java: In an object-oriented programming language, overriding
is a feature that allows a subclass or a child class to provide a specific
implementation of method that is only provided by one of its superclass
or parent class. When a same method in subclass has same name,same signature
and same return type as a method in superclass or parent class. When the
method in subclass is said to override method in superclass,
method overriding is one of the way by which java achieve runtime polymorphism.

q-> Real r=new Real();
    Test t=new Real();
No doubt same class reference object can hold the object of same class,
in java is this possible that superclass reference holds subclass object?
Give the specific alloborate content on this concept?

ans->

Yes, the super class reference variable can hold the sub class object actually, it is widening in case of objects (Conversion of lower datatype to a higher datatype).
But, using this reference you can access the members of super class only, if you try to access the sub class members a compile time error will be generated.

Example
In the following Java example, we have two classes namely Person and Student. The Person class has  one method displayPerson().
The Student extends the person class .It has a method displayData(). In the main method, we are assigning the subclass object with the super class reference variable.

class Person{
   public void displayPerson() {
      System.out.println("Data of the Person class: ");
   }
}
public class Student extends Person {
   public void displayStudent() {
      System.out.println("Data of the Student class: ");
   }
   public static void main(String[] args) {
      Person person = new Student();
      person.displayPerson();
   }
}
Output
Data of the Person class:

Accessing the sub class methods
When you assign the sub class object to the super class reference variable and, using this reference if you try to access the members of the sub class a compile time error will be generated.
Example
In this case, if you assign a Student object to reference variable of Person class as âˆ’
Person person = new Student();
Using this reference, you can access the method of the super class only i.e. displayPerson(). Instead if you try to access the sub class method i.e. displayStudent() a compile time error is generated.
Therefore, if you replace the main method of the previous program with the following a compile time error will be generated.

public static void main(String[] args) {
   Person person = new Student();
   person.displayStudent();
}
Compile time error
Student.java:33: error: cannot find symbol
   person.dispalyStudent();
        ^
   symbol: method dispalyStudent()
   location: variable person of type Person
1 error

But it can be done using typecasting:
((Student)person).displayStudent(); //will work

Java Arrays:

An array is a collection of similar type of data.
For eg:
if we want to store the names of 100 people, then we have to create an array
of the string type which stores 100 names.
String[] arr = new String[100];
Above object stores only string object.

Here the above arr object cannot store more than 100 objects, if i am storing
more elements/objects more than size of arr, it throws the exception
ArrayIndexOutOfBoundException. The memory management of arr is a process
of runtime so that above exception raise at the time of runtime.

How to declare array in java?
It can be a primitive datatype(int,float,char,boolean,double,byte etc..)
int[] arr;
or could be java objects
String[] arr;  or Test[] arr

*******   Object[] arr;         // Powerful arr
No doubt, arr depends upon similar type of datatype, but when we are creating
the object class arr we know object is mother class in java and object class
reference can hold any object in java(the concept applied in inheritance
and the concept is known as super class reference hold the subclass object
or type-class referencing);
So, object class arr can hold any object.

How to initialize arr in java?
int[] age = new int[5];
age[0]=12;
age[1]=12;
age[2]=12;
or
Scanner sc=new Scanner(System.in);
sout(enter age:);
for(int i=0;i<5;i++){
    age[i]=sc.nextInt();
}
or
for(int i=0;i<5;i++){
    age[i]=new Test();
}
or
** Object[] age=new Object[5];
age[0]=new Test();          // done by Class-casting
age[1]=new Real();
age[2]="test";

How to access elements of an array in java?
int[] age = new int[5];
sout(age[4]);
for(int i=0;i<5;i++){
    sout(age[i]);
}

q-> What are the operations that can be performed on array data structure?
ans->
In every language,For eg: c++,java,python etc.We are using arr but data
structure and operation we are performing on arr will be similar to all
the languages, the operation we are performing on arr:
1. Insertion in arr:
If we are inserting elements or object in arr,we have some conditions->
i. if we are inserting element at the head of arr i.e 0 indexing of arr.
ii. inserting element in mid of arr
iii. inserting element at tail/end of arr i.e (n-1) indexing of arr.
iv. traversing arr
v. measuring complexity of arr with help of BigO notation.
vi. copy arr from one arr to another
vii. deleting elements from the arr(head,tail,mid).

* Where we use matrices concept in real life

MultiDimensional Array:
can be defined in simple words as array of arrays, data in 
MultiDimensional array are stored in tabular form. 

Size of MultiDimensional array:
The total no. of elements that can be stored in MultiDimensional 
array can be calculated by multiplying the size of all the 
dimensions.
FOr eg: int[][] arr = new int[10][20];
The arr can store a total of 10*20 i.e 200 elements.

Application of MultiDimensional arrays:
1. are used to store the data in tabular form.For eg:
storing the rollno. and marks of students can be easily done
by MultiDimensional arr.
2. is to store images in 3d arrays.
3. In dynamic programming questioning MultiDimensional arr are
used to represent states of the problem.
4. Apart from these also we have Application in many standard 
algorithms, problems like matrices multiplication, graphs and
greed search problems.

StringBuffer in java:
StringBuffer is a class in java represent a mutable sequence of char
It provides an alternative to the immutable string class, allow
to modify the content of string without creating new object every
time.

There are some important features and methods of StringBuffer class:
1. StringBuffer object are mutable meaning that you can change the
content of buffer without creating a new object.
2. The initial capacity of StringBuffer can be specified when it 
is created or it can be set later with the ensure capacity method.
3*. the append method is used to add chars,strings or other objects
to end of buffer.
4. The insert method is used to insert chars ,strings or other 
objects at specified pos in the buffer.
5. the delete method is used to remove char from the buffer.
6. the reverse method is used to reverse the order of char in buffer.

//////////////////////// St2 ////////////////////////////////////

Note: Access modifiers table.

Packages:
(Access modifiers in java):

In order to use the data from one package to another package or within the package
we have to use the concept of access modifiers, in java we have four types of 
access modifiers they are public,protected,private and default.
Access modifiers make us to understand how to access the data within the package
class to class, interface to interface and interface to class.
In the other word,Access modifiers represent the visibililty of data and accessibility 
of data. 

1. Private access modifier is also known as native(local) access modifier.
2. default access modifier is also known as package access modifier.
3. protected access modifier is known as inherit access modifier.
4. public access modifier is known as universal access modifier.

Abstract Class:

In java, in all versions we have Abstract classes. In Abstract classes we have 
both implemented and unimplemented method.

abstract class Real{
    void fun(){      // implemented method
        //logic
    }

    abstract void run();      //unimplemented method
}

**-> In abstract class, if we are not defining any access modifier in front of 
variables or methods by default it will public.

***-> We can create the object of class, but in case of abstract class programmer
does not create object of abstract class.

Cannot create the object of Real class.

abstract class Real{
    void fun(){      // implemented method
        //logic
    }

    abstract void run();      //unimplemented method
}

Uses of abstract class:

class Test extends Real{

    void run(){
        //logic
    }
}

If i am declaring any class as a abstract class, its subclasses have the duty to 
give the implementation of declared method in abstract class inside the subclass.

Observation about Abstract class:
// Refer to Sunstar class in abstract package

1. Declaring any class as a abstract in java, concept coming from c++.
In java, if we have any declared method we have to write abstract but in case of 
c++ we have pure virtual functions which having null implementation(no logic but braces
present).

2. We cannot create the object of abstract class.

3. Like c++, an abstract class can contain constructors in java. And a constructor
of an abstract class is called when an instance of an inherited class is created.

4. In java, we can have an abstract class without any abstract method.
This allows us to create classes that cannot be instantiated  but can only be inherited.

5. In java, abstract classes can have final method.

6. Similar to the interface we can define static methods in an abstract class that can be called independently 
without an object. 


// Java Program to Illustrate 
// Static Methods in Abstract
// Class Can be called Independently
  
// Class 1
// Abstract class
abstract class Helper {
  
    // Abstract method
    static void demofun()
    {
  
        // Print statement
        System.out.println("ISHAN GUPTA");
    }
}
  
// Class 2
// Main class extending Helper class
public class GFG extends Helper {
  
    // Main driver method
    public static void main(String[] args)
    {
  
        // Calling method inside main()
        // as defined in above class
        Helper.demofun();
    }
}
Output
ISHAN GUPTA


//Also inner class
7. We can use the abstract keyword for declaring top-level classes (Outer class) as well as inner classes as abstract


import java.io.*;
  
abstract class B {
    // declaring inner class as abstract with abstract
    // method
    abstract class C {
        abstract void myAbstractMethod();
    }
}
class D extends B {
    class E extends C {
        // implementing the abstract method
        void myAbstractMethod()
        {
            System.out.println(
                "Inside abstract method implementation");
        }
    }
}
  
public class Main {
  
    public static void main(String args[])
    {
        // Instantiating the outer class
        D outer = new D();
  
        // Instantiating the inner class
        D.E inner = outer.new E();
        inner.myAbstractMethod();
    }
}

Q-> What do you mean by inner class?
ans->
The class inside the class, the concept is known as inner class.

class Test{

    void fun(){}

    class Real{
        void gun(){}
    }
}

q-> how to create the object of inner classes and call the non-static inner class
methods with suitable example?
ans-> Refer to Innerclass.java and obs7 of abstract

q-> What do you mean by mvc?   //Refer to src/Bank package

Interface with java:  //Refer to src/Bank package

Interface in java programming language is defined as a abstract type
used to specify the behaviour of class. An interface in java, is A
blueprint of a behaviour.

A java interface contain static constant and abstract method.
An interface in java is a mechanism to achieve abstraction There
can be only abstract method/declared method/unimplemented method
in java interface not the body of method. it is used to achieve 
abstraction and multiple inheritance in java.

Ambiguity Problem:

class Real{
    void fun(){
        sout("i am in realclass");
    }
}

class Test{
    void fun(){
        sout("i am in test class");
    }
}

class Bank extends Real,Test{
    Bank b=new Bank();
    b.fun();    //ambiguity problem to call which class fun method
}

Sol-> Interface

interface A{
    void fun();
}

interface B{
    void fun();
}

class Test implements A,B{
    
    //only name of method is coming int Test class.
    //implementation is given by test class so no ambiguity
    //problem arised in case of interface and we can achieve 
    //multiple inheritance.

    void fun(){
        sout("hello");
    }
}

In other words, you can say that interface have only abstract method
and variables, it cannot have a method body. Java interface also
represent is a relationship.

Like a class, an interface can have methods and variables but the
method declaration in interface are by default abstract(only signature
of methods are available).

The pts. to be remembered in interface:
1. Interface specify what a class must do and not how, it is A
blueprint of behaviour.
2. Interface do not have constructor, we cannot create object of 
interface in java. Even jvm cannot create object of interface internally.

Q-> Why do we use an interface?
ans->
1. it is used to achieve total abstraction(Hiding of code is abstraction. one
of the most important key factors of oops concept.Abstraction can be performed
by interfaces because the signature of methods and methods name are defined
in the interfaces).
2. Since java does not support multiple inheritance in case of classes by
using interface we can achieve multiple inheritance. In case of c++, we don't
have concept of interfaces but pure virtual functions are available in c++
having null implementation, it doesn't mean with help of pure virtual functions
we can perform multiple inheritance in c++ at the end c++ does not support
multiple inheritance.
3. Any class can extend only one class in java.
class A extends B  //supported
class A extends B,C  //not supported multiple inheritance

4. it is used to achieve a *loose coupling.

q->what do you mean by loose coupling and tight coupling in java?Which is the
best approach for building any java project in industry?
ans->
Loose coupling and tight coupling are the major fact for building projects
in industry. We do not perform tight coupling in our project because
tight coupling creates full dependency on resources or another class object
but in case of loose coupling we have factory design pattern to perform
loose coupling.

5. Interfaces are used to implement abstraction so question rise why use
interfaces when we have abstract classes?
ans->
THE first reason is that interfaces can implement multiple inheritance but
classes cannot.
The reason is abstract classes or normal classes contain non-final variables
whereas variable in an interface are final public static.

interface Test{
    int a;       // public static final
}

Note: The diff bw class and interface:

Class:
1. In a class, you can instantiate variables and create the object of classes.
2. Class can contain concrete(implemented) method.
3. The access modifiers like public,protected,private and default are be used.

Interface:
1. In an interface you cannot instantiate the variable.
2. Programmer and jvm does not have permission to create interface object,if
objects are not created there is no meaning to create the constructor inside
the interface.IN normal words we don't have constructor power in interface.
3. The interface cannot contain concrete method/implemented method/defined
method.
4. We can only use one modifier in case of interfaces i.e public.

Note: New feature added in interface in jdk 8.0 :
1. These days industry is updated so industries are grooming with a version
8,9 and 10.
2. Not defining the implementation in older versions, but now we can now add
implementations.

3. Suppose we need to add a new functionality in an existing interface,the old
code will not work as the classes have not implemented those new functions
so with the help of default implementation we will give a default body for
the newly added function.
So,after 7 version we can use two modifiers public and default modifiers
but default modifier will be placed in front of implemented method.

4.Another feature that was added in jdk8 is that we can now define static
method in interface that can be called independently without object.
**Static method does not perform overriding concept.Inheritance concept is
not applicable on static methods.

**Note:
1. ClassA extends ClassB
2. Class implements interface
3. InterfaceA extends InterfaceB

Extending Interface:
Only interface can inherit another interface by using extends keyword,When a
class implements an interface that inherit another interface it must provide
implementation for all the methods required by the interface inherit chain.

*****Marker interface:
Marker interface in java, will give the special power to the objects created in
java language. Serializable,clonable are the two marker interfaces which are
used in every project in real world industry.
Marker interface does not hold any method or variable, some programmers call
marker interface as empty interface.The power of marker interfaces will be
decided by the jvm at runtime.

//Refer to JavaCodes/Persist.java
1. Serializable interface: is available in java.io package. Whenever jvm runs
your program they will check any normal interfaces are available in class
or not, if any normal interface is available then jvm treat that object as a
special object.

Whenever java object is travelling on network by serializable interface,
then object will be in encrypted form,we have a terminology to decrypt that
object that is known as DeSerializable.

2. Cloneable Interface: Creating duplicate objects inside the server(application
server), the terminology is known as cloneable interface. Server does not give
original object to another resource for performing business logic, such particular
task we can perform with help of cloneable interface and clone method available
in object class. For creating any duplicate object our class will implement
cloneable interface and calls clone method from the object class,if our class
does not implement cloneable interface and calls clone method from object class
it will throw exception clonedoesnotsupport, so it is mandatory to implement
your class with cloneable interface.

Exception Handling:
1. Exception Handling in java, is one of the effective mean to handle the
runtime error so that regular flow of program/application can be preserved.
Java exception handling is a mechanism to handle runtime errors such as
classNotFoundException, I/OExceptions,SqlExceptions,remoteExceptions and so on.
2. Exception is unwanted and unexpected event which occur during the execution
of program during runtime that disturbs the normal flow of program. Exception
can be catched and handled by the program when an exception is occured in a
method it creates the object. This object is called exception object, it contains
info about the exception such as the main and the description of exception
and state of the program when the exception occured.

class Test{
    psvm(){
        int a=10;
        int b=0;
        try{
            int c=a/b;
        }catch(Exception e){
            sout(e);
        }
        for(int i=0;i<10;i++){
            sout("hello");
        }
    }
}

Q-> Write the major reasons why exceptions occur?
ans->
1. Invalid User Input   2. Device Failure        3. Loss of network
4. Physical Limitations(out of disk memory)     5. Code errors
 6. Opening an unavailable file

 Q-> Write the major reasons why error occur?
 ans->
 1. Error represent irrecoverable conditions such as jvm running out of memory.
 2. Liability and compatibility
 error are usually beyond the control of programmer and errors cannot be
 handled by programmer but exceptions can be handled by programmer, it is
 duty of programmer to handle the exception.

 q-> What is diff bw exception and error?
 ans->
 *Exceptions occur due to writing the illogical code by the programmer. We have
 two types of terminologies to handle the exceptions:
 1. Exception Handling mechanism: Exception Handling mechanisms used by the
 developers who are building the various applications.
 2. Assert: The assert mechanism used by the industrial tester, first is
 unit testing and second one is manual testing. People who are from testing
 field use the assertion while testing the application.

 *Error cannot be handled by programmer, they occur due to unwanted and
 wanted resources. stack overflow,memory leakage,shutdown server,hard disk full
 these are some problems which cannot be handled by programmer and create issue
 related to resource.

 Types of Exceptions:
 We have two types of exceptions:
 1. Checked Exceptions(Compile-time Exception): In case of checked exceptions it is mandatory to
 apply try-catch mechanism.Whenever we are writing the code of database,File
 I/O it will always throw checked exception.So,in java such type of code write
 inside the try-catch mechanism.
 2. UnChecked Exceptions(Run-time Exception): Unchecked Exceptions occurs at the time of runtime
 it occurs due to the logical reason like For eg:
 int a=10;
 int b=0;
 int c=a/b;   //logical exception
 It is non-mandatory to put try-catch in our program.

 Exception Hierarchy:

 Object -> Throwable
 -> Exception
 -> Error

 All the exception and error types are subclasses of throwable which is base
 class in hierarchy.
 One branch is headed by exception, this class is used for exception conditions
 that user program should catch. NullPointerException,NumberFormatException
 is an eg. of exception.
 Another branch that is known as error, this is used by the java runtime
 system to indicate errors having to-do with runtime environment itself.
 Stackoverflow error is an eg. of error class.

JDBC(Java Database Connectivity):
A jdbc driver is a jdbc api implementation used for connecting to a particular
type of database.There are several types of jdbc drivers:
1. Type-1 Driver: Contains a mapping to another data access api.An eg. of this
is ODBC driver for file management.
2. Type-2 Driver: is an implementation that uses client-side libraries of the
target database.Also called as native api driver.
3. Type-3 Driver: Uses middle-ware to convert jdbc calls into database specific
call also known as network protocol driver.
4. Type-4 Driver: Connect directly to the database by converting jdbc calls
into database     known as database protocol driver or thin driver.

The most commonly used type is Type-4 as it has advantage of being platform
independent connecting directly to database server provides better performance
compared to other types.
The downside of this type of driver is that its database specific, each database
has its own specific protocol.

This disadvantage has been overcome in hybernet framework.

*Connecting to the database:
To connect with a database, we simply have to initialize the driver and open
a database connection.

*Creating the connection:
To open a connection, we can use the static method known as getConnection()
that is available in class DriverManager.
If you want to establish the connection bw database and java, you have to
provide three arguments to getConnection().
1. Url + Port No.            2.Username              3.Password

If you are not providing the accurate url,username or password it will throw
checked exception.As these are resources, so it is mandatory to write this
method inside try-catch mechanism,If you are not writing this method inside
try-catch mechanism, it will throw compile-time error.

** Connection con = DriverManager.getConnection(url,username,password);

Format of url:     "jdbc:mysql://localhost:3306//<Database_name>"
username:   "root"
Password:   "root"

*Executing the Sql Statement:
To send sql query to database,we can use:
1. Prepared Statement      2. Callable Statement       3. Statement

which can be obtained using the Connection object.

*How to get Statement object:
    Statement s = con.createStatement();

q-> What is diff bw sql and Psql?
ans->
When we are working with sql, we are working with queries for retrieving the
data and saving the data inside the table and joins for joining the table.

Say,all the operations we can use in Psql which we are using in sql include that
we have (Procedures,functions,methods). If we want to call the procedure
from the java program then only one interface can help you that is known as
Callable Statement.
Procedure cannot be called through Statement and Prepared Statement.

q-> What do you mean by CRUD?
ans->
C --> Create   R --> Read(Select)   U --> Update   D --> Delete

Statement object have the responsibility of CRUD instructions.

For create and delete:  execute();
For read:  executeQuery();
For update:  executeUpdate();

StringBuilder:
StringBuilder in java represent a mutual sequence of characters. Since, String
class in java creates an immutable sequence of characters,the StringBuilder
class provides an alternative to String class as it creates a mutual sequence
of characters.
The function of StringBuilder class is very much similar to StringBuffer class.
As both of them provides an alternative to the class String by making a
mutable sequence of characters.However, StringBuilder class differ from
StringBuffer on basis of Synchronization.
The StringBuilder class provides no guarantee of synchronization whereas
StringBuffer class provides.Therefore, this class is designed for use as a
dropping replacement for StringBuffer.In-place where the StringBuffer was
used by a single thread as in generally the case. Where possible it is
recommended that this class is used in preference to StringBuffer as it will
be faster under most implementations.
Instance of StringBuilder class are not same when used by multiple threads.
If such synchronization is required then it is recommended to use StringBuffer
as StringBuilder is not thread safe and have higher performance compared
to StringBuffer.

Note: String class  -->   Immutable object
StringBuilder class  -->  Mutable Object but not thread safe(Not synchronized)
StringBuffer class  -->   Mutable Object and thread safe(Synchronized)

q->What is diff bw statement object and prepared Statement object?
ans->
Statement:
In the last program, we have built the jdbc code with a statement interface.
In jdbc code,statement object having a responsibility to send a request to
database server and database server having responsibility to check the query
syntax,every time with a statement object we are checking the query and
executing the query.It will take max. iteration bw java program and sql server
and holding the database connection for the long time.So, this is the biggest
drawback while working with a statement object.

Prepared Statement:
Prepared Statement is an alternative of Statement object,having far good
performance as compared to statement object bcoz prepared statement compiles
the query only once through sql server,with that compiled query we can use
compiled query max. time. No. of iteration bw java program and database
will be less while using Prepared Statement object.In case of performance,
prepared statement is more advanced statement object as compared to statement
object.

Throws:
Throws is a keyword,we can use in exception handling mechanism throw does not
handle the exception object,so we cannot say throw is exception handling
mechanism.We use throws keyword for indication purpose,throws is mainly used
in front of methods.
void fun() throws SQLException{
   //logic
}
In fun() method, throws indicates there may chance that this method throws
SQLException.SQLExceptions are those exceptions which are related to database.
So, with the try-catch mechanism we are handling the exceptions but throws
only indicates the exception.
So,whenever I am using throws keyword, I am not handling the exception,programmer
just indicates the exception.Mainly programmers handle the exceptions with
try-catch only at the calling phase of method.

psvm(){
    try{
        fun();
    }catch(SQLException e){
        sout(e);
    }
}

Throw:
try-catch is a mechanism which handle the exception and throw keyword converts
pre-defined exception into user-defined exception.
Case:
Mainly the applications we are building in real-time industry,those applications
are used by customers,there may be possibility our customers are from IT
or NON-IT backgrounds.For NON-IT background customers we have to convert
out pre-defined exception into user-defined exception.Such type of process
we can handle with throw keyword mainly we have seen in real-time projects
customers are familier with user-defined exceptions as compared to server-side
exceptions or localRepository-side exception.

Scrollable ResultSet in java Database Connectivity:
A scrollable ResultSet is one which allows us to retrieve the data in forward
direction as well as backward direction but no update allowed in order to
make the non-scrollable resultSet as scrollable resultSet, we must use the
following create statement which is present in connection interface.

Q-> Diff bw ResultSet and Scrollable ResultSet?
ans->   Refer to JdbcExample/ScrollableResultSet
ResultSet: we can move only in one direction(forward or up-to-down)
Scrollable ResultSet: we can move Bidirectional(up-to-down and down-to-up)

Threads in java:
Typically we can define threads as sub-process with lightweight with the
smallest unit of process and also have separate path of execution.These threads
are shared memory but they act independently.Hence,if there is an execution
in thread that do not affect the working of other threads despite them
sharing the same memory.

Multitasking:
To help of user operating system accommodates user the privilege of multitasking
where user can perform multiple task simultaneously on same system.This can
be done in two ways:
1. Process-based Multitasking(Multi-processing):
In this type of multitasking, process are heavy-weight and each process are
allocated by separate memory area.As the process is heavy-weight the cost of
communication bw process is high, and it takes long time for switching bw
processes.
2. Thread-based Multitasking:
As we discuss above, thread are provided with a lightweight nature and share
the same address-space and the cost of communication bw the thread is also
low.

Q-> Why threads are used?
ans-> We can understand why threads are being used as they have the advantage
of being light-weight and can provide communication bw multi-threads at a
low-cost contribution affecting multitasking within the share memory environment

q-> What is segmentation in programming language?
ans->
Segmentation is a memory management technique that can be used to improve
the performance of an operating system. By dividing physical memory into
segments, the operating system can better manage its memory use, improving
efficiency and performance.

Life-cycle of Thread:
There are diff states, Thread Transfer into during its lifetime, Let us know
about those states.

1. New State:  Thread t1 = new Thread();
2. Active State:   t1.start();
A thread that is new state by default get transfer to active state when it
involves the start method.Internally, start method calls the run method.
3. Waiting State:  t1.wait();
With the help of wait() method,we can wait our thread by invoking sleep() method.
sleep() method can stop execution for specific time period.
4. Time waiting State:
Will be done to stop the execution for some time period.
sleep() method is invoked and after the time expire the thread starts execution
its task.
5. Terminated State:
A thread will be terminated in foll. conditions:
1. When the task finish normally.
2. Sometime thread may terminate due to abnormal events like segmentation fault,
exceptions etc. and such type of termination is called abnormal events.
3. The terminate thread means it is dead and no longer available.

*Note:
q-> What is main thread?
ans->
We create main method in each and every java program which acts as entry pt.
for the code to execute.Similarly, in this multi-threading concept each program
has one main thread which was provided default by jvm.Hence,whenever
program is created in java,jvm provides the main thread for its execution.

q-1-> Explain thread life-cycle?
q-2-> What is diff bw multi-tasking,multi-programming,multi-processing and
multi-threading?

q-> How to create thread in java?
ans->
We can create thread in java using two ways:
1). extends Thread:  // Refer to Multithreading/extendThreadUse
By extending thread class, we can run thread in java by using
thread class which provides the constructors and methods for creating and
performing operations on the thread which extend the thread class that can
implement Runnable interface.
We can use foll. constructors:
1. Thread();
2. Thread(Runnable r);
3. Thread(String thread_name);
4. Thread(Runnable r,String thread_name);

2). implements Runnable:   // Refer to Multithreading/implementRunnable
