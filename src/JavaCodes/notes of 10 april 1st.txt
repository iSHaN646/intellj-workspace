q1->what do you mean by unicode in java?

ans1->
an international encoding standard for use with different languages and scripts, 
by which each letter, digit, or symbol is assigned a unique numeric value that applies
 across different platforms and programs.

q2->why char primitive data types take 2 bytes in java?

ans2->
in java , char follows unicode encoding scheme which supports 60+ languages due to 
which it ranges from 0 to 65535 which cannot be stored on 1 byte whereas in c/c++
ascii scheme is followed supporting only english language ranges from 0 to 255 which 
can be stored in 1 byte.

q3->what are the data types in java?
ans3-> we have two categories in java->

1. Primitive datatype-> As primitive datatype we have already read in c language
(int,float,char,byte) but string datatype is not available in c, to hold any string 
in c language we have to create char array which is difficult approach while 
using string in c language because array data structure we have to define while
holding any string but in java String class introduced in java.

2. Non-Primitive datatype-> String is a non-primitive datatype introduced in java
which hold directly string. String class hold directly string we dont need to 
create char array. Whenever i am creating the string class object, the obj of 
string stored inside the string constant pool.

q4-> How to create a string object?
ans4-> String a = "Real";   ->  string constant pool
String a =  new String("abc");   -> heap

First approach: is the best methology to create string object

Note: 1. We have wrapper classes in java which is used for conversion, specific datatype 
value to another datatype.

2. but if we try to convert string "abc" to integer type we get NumberFormatException
whereas converting string "101" to integer is perfectly fine.

3. if we do not write main method in our program , it will compile fine bcoz there 
is no syntax error and no memory allocation takes place at compile time
but when we run our program jvm will get activated which will first search for
main method in our program,it will throw error ->

Error: Main method not found in class Test, please define the main method as:
   public static void main(String[] args)
or a JavaFX application class must extend javafx.application.Application

Note: THIS keyword

this keyword represent current object of class.
CASE1: suppose i have two objects of same class, i have to check
which current thread is activated in my program we can analyze 
with this keyword.

q5-> what is diff bw equality operator(==) and equals method?

ans5-> Equality operator:
1. if we are using equality operator with the integer variables,
it will check values of variables.
2. if we are using equality operator to check the objects in that 
case it will check address of objects.

eg->
Test t=new Test();
Test t1=new Test();

if(t==t1){
	System.out.println("hi");
}else{
	System.out.println("bie");  //ans
}

Equals Method:
equals method always check the content of two strings

Both equals method and equality operator are used to compare two
objects in java. equality operator is an operator and equals is a
method defined in String class but equality operator compares 
reference of memory location of objects inside heap area,whether 
they point to same location or not.
In general both equals and equality operator in java are used to 
compare objects to check equality but there are some of differences
bw the two->
1. The main diff bw the equals method and equality operator is 
that one is method and second one is operator.
2. We can use equality operator for references comparision
(addresses comparision) and .equals method for content comparision
In simple words, equality operator check if both objects point to
same memory allocation whereas equals method check comparision of
values inside the object.

Q5-> Diff bw reference variable and variable?
ans5->
int b=10; where b is a variable which holds value
Test t= new Test(); where t is a reference variable which holds objects

Variable can hold only values, we can define variable in c language 
where object concept is not available.
But reference variable are those variable which hold the object

Note: 1. exit(Integer) used to shutdown the jvm, so all the code after
the exit statement will not execute. 

2. If there is no constructor in class, but you are calling constructor
using new keyword ,then compiler will automatically insert the
default constructor.

Imp:Note: 1. if we want to restrict any class from being creating objects
using new keyword, make the constructor of that class private.
eg: System class have private constructor, you cannot create its
object.

Private Constructor:

if i am creating any private constructor inside the class or making 
any constructor as private, we cannot create object of that class
outside the class.

Method overloading:

same method name having diff parameters, we can achieve method 
overloading concept

void println(int a){};
void println(Long a){};

In java, two or more methods may have the same name, if they differ
in parameters(diff no. of parameters or diff types of parameters or both)
These method are called overload methods and this feature is called
method overloading.

Q6: Why method overloading?
ans6:

Suppose you have to perform the addition method on given no.,but
there can be any no. of arguments(Lets say either 2 or 3 arguments)
In order to complete the task, you can create two method .
int sum2(int a,int b);
int sum3(int a,int b,int c);

However other programmers as well as you in the future may get confused
as the behaviour of both methods are same but differ by name.
The better way to complish this task is by overloading method and
depending upon the argument passed, one of the overloaded method
is called, this helps to increase the readability of program.

Polymorphism:
Polymorphism divided into 2 phases:
1. Overloading(Compile time Polymorphism)   2. Overriding(runtime polymorphism)

Overloading:
Overloading is known as compile time polymorphism checking methods parameters
at time of compilation makes overloading concept as compile time polymorphism.

eg: Compile time error
void fun(int a){}
void fun(int a){}
psvm{
       fun(10,10.5f);     // checking parameters at compile time
}

System class:

System class having private constructor we cannot create the object of
system class but we have permission to create the reference variable
of system class


Note: Not creating the object of System as private constructor
but creating the reference of System class
 System sc=null;   // Reference variable
 sc.out.println("hello"); // Working

 Note: Static:
 Context of the class : is the memory name where all the static var,methods,
 blocks will be allocated at the compile time.

 Defining
 public static void main(String args[]){}

 q7->Why main method define static in java programming?
 ans7->
 We know non-static methods will be called after object creation, if java
 people defined main method as non-static programmer having the responsibility
 to create the object of that class where main method is defined, but
 static concept is a part of compile time memory allocation and we can
 call static data members and method through className here at the runtime
 classLoader having the responsibility to load the .class, main method will
 be called through class name because main method is static.

Refer to NstaticInSt:
Note: We cannot use non-static reference variable in static methods.


wap to concatenate two strings string values will be given through command line
argument?

wap getting values from the command line argument , you have to check
both the strings are equal or not?

IMP:note:
Refer to PracticeTest and PracticeTestMain:
As PracticeTest have private constructor,we cannot create object in main class
but we are creating static function in PracticeTest class which will return
the object of class(this concept is called factory design method).

Factory method(Factory design pattern) or static methods:
Mainly static methods are factory methods which returns object of class, in
real world terminology IT professionals follow the design pattern in their
projects known as factory design pattern.Factory design pattern is used
to create the factory and serve the objects to other classes, mainly this
design pattern is used for database connectivity realtime projects.

Inheritance:
It is the one of key feature of oop that allows us to create a new class from
existing class.
The new class that is created is known as subclass,child or derived class
and the existing class from where that child class is derived is known as
super class,parent class,base class.
The extends keyword is used to perform inheritance in java.

package JavaCodes;

 class inheritance {

    public inheritance() {
       System.out.println("inheritance class constructor"); //1
   }
   void fun() {
       System.out.println("hello i am in fun()"); //2
   }
}

public class child extends inheritance {

    public static void main(String[] args) {
        child c = new child();
         c.fun();
    }
}

Every non-inheriting class inherits Object class.
Object class have foll functions:
1. void finalize();
2. boolean equals(Object o);
3. int hashCode();
4. void main(String[] args);
5. void notify();
5. void notifyAll();
5. String toString();
5. void wait();
5. void wait(long timeout);
5. void wait(long timeout,int nanos);
6.    getClass();
package JavaCodes;

 class inheritance extends Object{


}

public class child extends inheritance {

    public static void main(String[] args) {
        child c = new child();
         c.hashcode();
    }
}

Is a relationship(Inheritance):
In java,inheritance is an Is a relationship i.e we use inheritance only
if there exist an Is a relationship bw two classes. For eg:
1. Car is a vehicle

class Vehicle{}
class Car extends Vehicle{}

here car can inherit from vehicle and car is a subclass of vehicle.

q-> Why we use inheritance?
ans->
1. The most important use of inheritance in java, is code re-usability.
The code that is present in parent class be directly used by child class.
2. Method overriding is also known as runtime polymorphism, hence we can
achieve polymorphism in java with help of inheritance.

Types of inheritance:
1. Single inheritance->   B extends A
In single inheritance, a single subclass extends from the single superclass.

2. Multi-level inheritance-> C extends B and B extends A
in multi-level inheritance, a subclass extend from a super class and then
same subclass act as a superclass from the another class.

3. Hierarchical inheritance-> Only A is super class and every other class
extends A class
in hierarchical inheritance, multiple subclass extend from a single superclass

4. Multiple inheritance-> A and B class are super classes which is extended
by class C
class C extends A,B
C c=new C();
c.fun();//ambiguity

5. Hybrid inheritance-> Class B and C extends class A, and class D
extends class B and C.
Hybrid inheritance is a combination of two or more type of inheritance.

Super Keyword:
class A{ int a=10; }
class B extends A{
    int a=20;
    void foo(){
        int a=30;
        System.out.println(a); //30
        System.out.println(this.a); //20
        System.out.println(super.a); //10 //super keyword is used in three cases:
//   Case1: Using super in case of variables we get access of super class
//   variables.
//   Case2: Super keyword can be used in case of methods,we can call
//   super class methods with help of super keyword.
//   Case3: We can call super class constructor with help of super keyword
     }
    public static void main(String args[]){
        B b=new B();
        b.foo();
    }
}

final keyword:
final is non-access modifier, applicable only to a variable,method or class.
final keyword is used in diff contexts:
1. final variable    2. final class    3. final methods

final variable:
When the variable is declared as final, its value cannot be changed and
it has been initialized only once. This is useful for declaring constant
or other values that should not be modified.

final method:
When the method is declared as final, it cannot be overriden by subclass,
it is used for methods that are part of a class public api and should
not be modified in subclasses.

final class:
When a class is declared as final, it cannot be extended by a subclass,
this is useful for classes that are intended to be used has is and should
not be modified or extended.

Overriding(runtime polymorphism):

class Test{
    void fun(){
        sout("hi");
    }
}
class Real extends Test{
    void fun(){
        sout("bie");
    }

    psvm(String args[]){
        Real t=new Real();
        t.fun(); //bie
    }
}

Overriding in java: In an object-oriented programming language, overriding
is a feature that allows a subclass or a child class to provide a specific
implementation of method that is only provided by one of its superclass
or parent class. When a same method in subclass has same name,same signature
and same return type as a method in superclass or parent class. When the
method in subclass is said to override method in superclass,
method overriding is one of the way by which java achieve runtime polymorphism.

q-> Real r=new Real();
    Test t=new Real();
No doubt same class reference object can hold the object of same class,
in java is this possible that superclass reference holds subclass object?
Give the specific alloborate content on this concept?

ans->

Yes, the super class reference variable can hold the sub class object actually, it is widening in case of objects (Conversion of lower datatype to a higher datatype).
But, using this reference you can access the members of super class only, if you try to access the sub class members a compile time error will be generated.

Example
In the following Java example, we have two classes namely Person and Student. The Person class has  one method displayPerson().
The Student extends the person class .It has a method displayData(). In the main method, we are assigning the subclass object with the super class reference variable.

class Person{
   public void displayPerson() {
      System.out.println("Data of the Person class: ");
   }
}
public class Student extends Person {
   public void displayStudent() {
      System.out.println("Data of the Student class: ");
   }
   public static void main(String[] args) {
      Person person = new Student();
      person.displayPerson();
   }
}
Output
Data of the Person class:

Accessing the sub class methods
When you assign the sub class object to the super class reference variable and, using this reference if you try to access the members of the sub class a compile time error will be generated.
Example
In this case, if you assign a Student object to reference variable of Person class as −
Person person = new Student();
Using this reference, you can access the method of the super class only i.e. displayPerson(). Instead if you try to access the sub class method i.e. displayStudent() a compile time error is generated.
Therefore, if you replace the main method of the previous program with the following a compile time error will be generated.

public static void main(String[] args) {
   Person person = new Student();
   person.displayStudent();
}
Compile time error
Student.java:33: error: cannot find symbol
   person.dispalyStudent();
        ^
   symbol: method dispalyStudent()
   location: variable person of type Person
1 error

But it can be done using typecasting:
((Student)person).displayStudent(); //will work

Java Arrays:

An array is a collection of similar type of data.
For eg:
if we want to store the names of 100 people, then we have to create an array
of the string type which stores 100 names.
String[] arr = new String[100];
Above object stores only string object.

Here the above arr object cannot store more than 100 objects, if i am storing
more elements/objects more than size of arr, it throws the exception
ArrayIndexOutOfBoundException. The memory management of arr is a process
of runtime so that above exception raise at the time of runtime.

How to declare array in java?
It can be a primitive datatype(int,float,char,boolean,double,byte etc..)
int[] arr;
or could be java objects
String[] arr;  or Test[] arr

*******   Object[] arr;         // Powerful arr
No doubt, arr depends upon similar type of datatype, but when we are creating
the object class arr we know object is mother class in java and object class
reference can hold any object in java(the concept applied in inheritance
and the concept is known as super class reference hold the subclass object
or type-class referencing);
So, object class arr can hold any object.

How to initialize arr in java?
int[] age = new int[5];
age[0]=12;
age[1]=12;
age[2]=12;
or
Scanner sc=new Scanner(System.in);
sout(enter age:);
for(int i=0;i<5;i++){
    age[i]=sc.nextInt();
}
or
for(int i=0;i<5;i++){
    age[i]=new Test();
}
or
** Object[] age=new Object[5];
age[0]=new Test();          // done by Class-casting
age[1]=new Real();
age[2]="test";

How to access elements of an array in java?
int[] age = new int[5];
sout(age[4]);
for(int i=0;i<5;i++){
    sout(age[i]);
}

q-> What are the operations that can be performed on array data structure?
ans->
In every language,For eg: c++,java,python etc.We are using arr but data
structure and operation we are performing on arr will be similar to all
the languages, the operation we are performing on arr:
1. Insertion in arr:
If we are inserting elements or object in arr,we have some conditions->
i. if we are inserting element at the head of arr i.e 0 indexing of arr.
ii. inserting element in mid of arr
iii. inserting element at tail/end of arr i.e (n-1) indexing of arr.
iv. traversing arr
v. measuring complexity of arr with help of BigO notation.
vi. copy arr from one arr to another
vii. deleting elements from the arr(head,tail,mid).

* Where we use matrices concept in real life

MultiDimensional Array:
can be defined in simple words as array of arrays, data in 
MultiDimensional array are stored in tabular form. 

Size of MultiDimensional array:
The total no. of elements that can be stored in MultiDimensional 
array can be calculated by multiplying the size of all the 
dimensions.
FOr eg: int[][] arr = new int[10][20];
The arr can store a total of 10*20 i.e 200 elements.

Application of MultiDimensional arrays:
1. are used to store the data in tabular form.For eg:
storing the rollno. and marks of students can be easily done
by MultiDimensional arr.
2. is to store images in 3d arrays.
3. In dynamic programming questioning MultiDimensional arr are
used to represent states of the problem.
4. Apart from these also we have Application in many standard 
algorithms, problems like matrices multiplication, graphs and
greed search problems.

StringBuffer in java:
StringBuffer is a class in java represent a mutable sequence of char
It provides an alternative to the immutable string class, allow
to modify the content of string without creating new object every
time.

There are some important features and methods of StringBuffer class:
1. StringBuffer object are mutable meaning that you can change the
content of buffer without creating a new object.
2. The initial capacity of StringBuffer can be specified when it 
is created or it can be set later with the ensure capacity method.
3*. the append method is used to add chars,strings or other objects
to end of buffer.
4. The insert method is used to insert chars ,strings or other 
objects at specified pos in the buffer.
5. the delete method is used to remove char from the buffer.
6. the reverse method is used to reverse the order of char in buffer.

//////////////////////// St2 ////////////////////////////////////

Note: Access modifiers table.

Packages:
(Access modifiers in java):

In order to use the data from one package to another package or within the package
we have to use the concept of access modifiers, in java we have four types of 
access modifiers they are public,protected,private and default.
Access modifiers make us to understand how to access the data within the package
class to class, interface to interface and interface to class.
In the other word,Access modifiers represent the visibililty of data and accessibility 
of data. 

1. Private access modifier is also known as native(local) access modifier.
2. default access modifier is also known as package access modifier.
3. protected access modifier is known as inherit access modifier.
4. public access modifier is known as universal access modifier.

Abstract Class:

In java, in all versions we have Abstract classes. In Abstract classes we have 
both implemented and unimplemented method.

abstract class Real{
    void fun(){      // implemented method
        //logic
    }

    abstract void run();      //unimplemented method
}

**-> In abstract class, if we are not defining any access modifier in front of 
variables or methods by default it will public.

***-> We can create the object of class, but in case of abstract class programmer
does not create object of abstract class.

Cannot create the object of Real class.

abstract class Real{
    void fun(){      // implemented method
        //logic
    }

    abstract void run();      //unimplemented method
}

Uses of abstract class:

class Test extends Real{

    void run(){
        //logic
    }
}

If i am declaring any class as a abstract class, its subclasses have the duty to 
give the implementation of declared method in abstract class inside the subclass.

Observation about Abstract class:
// Refer to Sunstar class in abstract package

1. Declaring any class as a abstract in java, concept coming from c++.
In java, if we have any declared method we have to write abstract but in case of 
c++ we have pure virtual functions which having null implementation(no logic but braces
present).

2. We cannot create the object of abstract class.

3. Like c++, an abstract class can contain constructors in java. And a constructor
of an abstract class is called when an instance of an inherited class is created.

4. In java, we can have an abstract class without any abstract method.
This allows us to create classes that cannot be instantiated  but can only be inherited.

5. In java, abstract classes can have final method.

6. Similar to the interface we can define static methods in an abstract class that can be called independently 
without an object. 


// Java Program to Illustrate 
// Static Methods in Abstract
// Class Can be called Independently
  
// Class 1
// Abstract class
abstract class Helper {
  
    // Abstract method
    static void demofun()
    {
  
        // Print statement
        System.out.println("ISHAN GUPTA");
    }
}
  
// Class 2
// Main class extending Helper class
public class GFG extends Helper {
  
    // Main driver method
    public static void main(String[] args)
    {
  
        // Calling method inside main()
        // as defined in above class
        Helper.demofun();
    }
}
Output
ISHAN GUPTA


//Also inner class
7. We can use the abstract keyword for declaring top-level classes (Outer class) as well as inner classes as abstract


import java.io.*;
  
abstract class B {
    // declaring inner class as abstract with abstract
    // method
    abstract class C {
        abstract void myAbstractMethod();
    }
}
class D extends B {
    class E extends C {
        // implementing the abstract method
        void myAbstractMethod()
        {
            System.out.println(
                "Inside abstract method implementation");
        }
    }
}
  
public class Main {
  
    public static void main(String args[])
    {
        // Instantiating the outer class
        D outer = new D();
  
        // Instantiating the inner class
        D.E inner = outer.new E();
        inner.myAbstractMethod();
    }
}

Q-> What do you mean by inner class?
ans->
The class inside the class, the concept is known as inner class.

class Test{

    void fun(){}

    class Real{
        void gun(){}
    }
}

q-> how to create the object of inner classes and call the non-static inner class
methods with suitable example?
ans-> Refer to Innerclass.java and obs7 of abstract

q-> What do you mean by mvc?   //Refer to src/Bank package

Interface with java:  //Refer to src/Bank package

Interface in java programming language is defined as a abstract type
used to specify the behaviour of class. An interface in java, is A
blueprint of a behaviour.

A java interface contain static constant and abstract method.
An interface in java is a mechanism to achieve abstraction There
can be only abstract method/declared method/unimplemented method
in java interface not the body of method. it is used to achieve 
abstraction and multiple inheritance in java.

Ambiguity Problem:

class Real{
    void fun(){
        sout("i am in realclass");
    }
}

class Test{
    void fun(){
        sout("i am in test class");
    }
}

class Bank extends Real,Test{
    Bank b=new Bank();
    b.fun();    //ambiguity problem to call which class fun method
}

Sol-> Interface

interface A{
    void fun();
}

interface B{
    void fun();
}

class Test implements A,B{
    
    //only name of method is coming int Test class.
    //implementation is given by test class so no ambiguity
    //problem arised in case of interface and we can achieve 
    //multiple inheritance.

    void fun(){
        sout("hello");
    }
}

In other words, you can say that interface have only abstract method
and variables, it cannot have a method body. Java interface also
represent is a relationship.

Like a class, an interface can have methods and variables but the
method declaration in interface are by default abstract(only signature
of methods are available).

The pts. to be remember in interface:
1. Interface specify what a class must do and not how, it is A
blueprint of behaviour.
2. Interface do not have constructor, we cannot create object of 
interface in java. Even jvm cannot create object of interface internally.

















